[题目链接](https://codeforces.com/contest/1702/problem/F)

题目大意：给出两个可重集合$a$与$b$，可以对$b$中的每个元素做乘以$2$和除以$2$（向下取整）若干次的操作，问能否令$b$等于$a$.

题解;

我们可以看一下每个元素质因数分解后的形式，不难发现，如果一个数可以由另一个数不断乘$2$得到，那么二者除了$2$以外的质因子的指数应该都相同。

那么，我们可以先将$a$中每个元素不断除以$2$，直到该元素无法被$2$整除为止，然后，我们可以继续看此时$a$中每个元素能否由$b$得到。

由于元素除以$2$时需要向下取整，那么，当元素为奇数时，相当于取其质因子分解中最小质因子除以$2$向下取整。考虑到$a$中元素都为奇数，因此此时不应该令$b$中元素乘以$2$，而仅应令其做除以$2$操作。

我们可以贪心地来做：每次取最大的元素除以$2$，然后检查是否在$a$中出现，出现则去掉。

这样会不会漏判误判呢？我们可以分类讨论：

若$a$中只有一个元素可以由最大值得到，显然最大值的最终转化目标就是该元素;

若$a$中有两个元素可以由最大值得到，设为$num_1$和$num_2$，$num_1 < num_2$，我们的转化会令最大值变为$num_2$，那么我们需要考虑，是否会有另一个数可以转化为$num_2$而不能转化为$num_1$从而因为$num_2$被最大值占了而无法完成转化？显然$num_2$也可以转化为$num_1$，所以不会有这种情况。

代码：

```cpp
#include<bits/stdc++.h>
#define debug(x) cout << #x << " = " << x << endl
#define ll long long
using namespace std;
const ll N = 2e5 + 5;
ll n;
ll a[N];
ll b[N];
int main()
{
	ll _;
	cin >> _;
	while(_ -- )
	{
		map<ll,ll>mp;
		cin >> n;
		for(ll i = 1; i <= n; i ++ )
		{
			cin >> a[i];
		}
		for(ll i = 1; i <= n; i ++ )
		{
			cin >> b[i];
		}
		for(ll i = 1; i <= n; i ++ )
		{
			while(a[i] % 2 == 0)
			{
				a[i] /= 2;
			}
			mp[a[i]] ++ ;
		}
		int f = 0;
		for(ll i = n; i >= 1; i -- )
		{
			while(b[i] > 0)
			{
				if(mp[b[i]] > 0)
				{
					mp[b[i]] -- ;
					break;		
				}		
				b[i] /= 2;
			}
			
			if(b[i] == 0)
			{
				f = 1;
				break;
			}
		}
		if(f)
		{
			cout << "NO" << endl;
		}
		else
		{
			cout << "YES" << endl;
		}
		
	}
}
```